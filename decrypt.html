import numpy as np
from PIL import Image

def rail_fence_encrypt(plaintext, rails):
    rail = [['\n' for _ in range(len(plaintext))] for _ in range(rails)]
    dir_down = None
    row, col = 0, 0

    for char in plaintext:
        if row == 0:
            dir_down = True
        if row == rails - 1:
            dir_down = False
        rail[row][col] = char
        col += 1
        if dir_down:
            row += 1
        else:
            row -= 1

    ciphertext = ''
    for i in range(rails):
        for j in range(len(plaintext)):
            if rail[i][j] != '\n':
                ciphertext += rail[i][j]
    return ciphertext

def encode_text(image_path, dest_path, plaintext, rails):
    # Open the image and convert to RGB (not RGBA)
    img = Image.open(image_path).convert('RGB')
    pixels = np.array(img)

    # Encrypt using Rail Fence Cipher
    ciphertext = rail_fence_encrypt(plaintext, rails)
    # Convert encrypted message to binary with a unique delimiter
    binary_message = ''.join(format(ord(char), '08b') for char in ciphertext) + '0000000011111111'  # Extended delimiter

    if len(binary_message) > pixels.size:  # 3 channels (RGB)
        raise ValueError("Encrypted message too long to encode in the image")

    # Embed binary message into LSB of each channel
    index = 0
    for i in range(pixels.shape[0]):
        for j in range(pixels.shape[1]):
            if index >= len(binary_message):
                break
            for k in range(3):  # RGB channels only
                if index < len(binary_message):
                    pixels[i, j, k] = (pixels[i, j, k] & 0xFE) | int(binary_message[index])
                    index += 1
        if index >= len(binary_message):
            break

    # Save the modified image
    encoded_img = Image.fromarray(pixels)
    encoded_img.save(dest_path, format='PNG')
    print("Ciphertext:", ciphertext)  # Display ciphertext on terminal

def decode_text(image_path, rails):
    # Open the image
    img = Image.open(image_path).convert('RGB')
    pixels = np.array(img)

    # Extract LSB from each pixel
    binary_message = ""
    for i in range(pixels.shape[0]):
        for j in range(pixels.shape[1]):
            for k in range(3):  # RGB channels
                binary_message += str(pixels[i, j, k] & 1)
                if len(binary_message) >= 16 and binary_message[-16:] == "0000000011111111":  # Check extended delimiter
                    # Convert binary to encrypted text
                    binary_data = binary_message[:-16]  # Remove delimiter
                    if len(binary_data) % 8 != 0:
                        raise ValueError("Corrupted binary data")
                    encrypted_text = ''.join(chr(int(binary_data[i:i+8], 2)) for i in range(0, len(binary_data), 8))
                    return rail_fence_decrypt(encrypted_text, rails)

    raise ValueError("No encoded message found or image corrupted")

def rail_fence_decrypt(ciphertext, rails):
    rail = [['\n' for _ in range(len(ciphertext))] for _ in range(rails)]
    dir_down = None
    row, col = 0, 0

    # Mark the rails
    for i in range(len(ciphertext)):
        if row == 0:
            dir_down = True
        if row == rails - 1:
            dir_down = False
        if rail[row][col] == '\n':
            rail[row][col] = '*'
        if dir_down:
            row += 1
        else:
            row -= 1
        col += 1

    # Put the cipher text into the rails
    index = 0
    for i in range(rails):
        for j in range(len(ciphertext)):
            if rail[i][j] == '*' and index < len(ciphertext):
                rail[i][j] = ciphertext[index]
                index += 1

    # Read the plaintext
    result = []
    row, col = 0, 0
    for i in range(len(ciphertext)):
        if row == 0:
            dir_down = True
        if row == rails - 1:
            dir_down = False
        if rail[row][col] != '\n':
            result.append(rail[row][col])
            col += 1
        if dir_down:
            row += 1
        else:
            row -= 1
    return ''.join(result)

# Example usage with user input
if __name__ == "__main__":
    try:
        image_path = input("Enter source image path: ")
        dest_path = input("Enter destination image path: ")
        plaintext = input("Enter plaintext to encode: ")
        rails = int(input("Enter number of rails: "))
        encode_text(image_path, dest_path, plaintext, rails)
        decoded_message = decode_text(dest_path, rails)
        print("Decoded message:", decoded_message)
    except Exception as e:
        print(f"Error: {e}")
